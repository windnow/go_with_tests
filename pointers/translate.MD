Pointers & errors
=================

В последней главе были изучены структуры, которые позволяют зафиксировать несколько значений, связанных с некоторой концепцией.

В какой то момент может появится желание использовать структуры для управления состоянием, предоставление методов позволяет пользователям управлять состоянием таким образом, что бы разработчим мог его контролировать.

Давайте создадим структуру `Wallet` для хранения `Bitcoin`

## Сначала напишем тест 


    func TestWallet(t *testing.T) {
        wallet := Wallet{}

        wallet.Deposit(10)

        got := wallet.Balance()
        want := 10

        if got != want {
            t.Errorf("got %d want %d", got, want)
        }
    }

В предыдущем примере доступ к полям осуществлялся напрямую по имени поля, однако в нашем *очень безопасном кошельке* внутреннее состояние не должно быть доступно извне. Мы можем контролировать доступ с помощью методов.

## Попытка запуска тесте

    wallet_test.go:6:12: undefined: Wallet

## Напишем минимальное количество кода для запуска теста и просмотра ошибки теста

Компилятор не знает, что такое `Wallet`, так что давайте определим его.

    type Wallet struct {}

Теперь, после добавление `Wallet` попробуйте запустить тест снова

    wallet_test.go:8:8: wallet.Deposit undefined (type Wallet has no field or method Deposit)
    wallet_test.go:10:15: wallet.Balance undefined (type Wallet has no field or method Balance)

Нам нужно определить эти методы

Не забудьте, что нужны минимальные изменения, достаточные для запуска теста. Мы должны убедиться, что наш тест не пройдет выдав четкое сообщение об ошибке.

    func (w Wallet) Deposit(amount int) {

    }

    func (w Wallet) Balance() int {
        return 0
    }

Если синтаксис не понятен, то вернитесь назад, и прочтите секцию о структурах.

Теперь тесты должны скомпилироваться и запуститься.

    wallet_test.go:14: got 0 want 10

## Напишем минимальный код, для успеха теста

Нам понадобится переменная `balance` для хранения состояние

    type Wallet struct {
        balance int
    }

В Go, если имя сущности (перемменной, типа, функции) начинается со строчной буквы, тогда она доступна лишь в рамках пакета, в котором определена (приватная)

Помните - в структуре мы можем получить доступ к внутреннему полю `balance` используя переменную "получатель"

    func (w wallet) balance() int {
        return w.balance
    }

## ????

